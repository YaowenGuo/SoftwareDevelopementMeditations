# 程序的内存使用

程序占用内存可以问题
- 代码区
- 数据区
- 堆
- 栈


本文的重点是：

> 程序中如何申请和管理内存? 在程序中管理内存的难点和解决方案？以及个各种解决方案的应用场景和优缺点。如何合理的避免这些方案的缺陷。

根据程序使用内存方式的不同，内存可以分为代码区、数据区、堆、栈。代码区和数据区分别用来存放程序的代码和数据，大小是固定的，在程序运行之前就可以确定。而栈和堆的大小则是运行时不断地变化。

其中**栈**内存是程序是函数调用时分配，函数返回时自动释放，它的分配和删除是由编译器为程序员隐式管理的，因此有时也被称为自动内存。

在程序运行中，有些变量的声明周期会远大于函数的调用（在函数之间传递），而且在运行时才能确定其大小（例如用户输入的恩荣），对于长寿命内存的这种需求，有了第二种内存，即**堆**内存。**在开发者有明确需要时`显式`从堆内存申请，并且在不需要时需要将内存释放**。早期，这部分完全由应用开发者承担，由于内存管理的不当会引发很多难以察觉到的bug，为了避免这类问题，现代程序语言也出现了各种技术来处理堆内存管理的各种功能问题，从而将减轻程序员的痛苦。我们先从简单的开始，然后逐步了解不同的解决方案，以及各种解决方案的弊端。

由于堆内存分配需要显式分配的特点，而且使用方式更为多样，因此对用户和系统都提出了更多挑战。因此，它是我们接下来讨论的重点

## 开发者完全承担

在这种内存中，所有的分配和取消分配都由应用应用开发者明确处理。毫无疑问，这是一项沉重的责任！这也是导致许多错误的原因。

由于 C 语言出现的非常早，并且更接近底层，C 语言并没有内置一种从堆申请内存的方式，而是使用标准库的一对 `mallco` 和 `free`来申请和释放内存，它们是对操作系统调用的封装，真的足够接近底层了。
以下示例展示了 C 语言中内存的分配：
```C
void func() {
int *x = (int *) malloc(sizeof(int));
...
free(x);
}
```
该示例同时演示了栈和堆内存分配。首先，当编译器看到声明的整数指针 (int *x) 时，它就知道要为该指针留出空间了，编译器也会保证预留的空间在函数调用返回时被正确释放。接着，程序调用 malloc() ，该调用会请求在堆上为一个整数提供空间；该例程会返回这样一个整数的地址（成功时为 NULL，失败时为 NULL），然后将其存储在堆栈上供程序使用。

### 还没开始就结束了

malloc 和 free 看起来非常简单，就是一个成对的函数调用，实际使用起来却状况百出。malloc 只有一个参数，确定要申请多少字节。不过，由于 C 语言数据类型在不同平台上可能是不同字节（例如 64 位系统中，Unix 上 `long` 是 8 字节，而 Windows 上是 32 字节。`int` 类型在 32 位系统上是 4 字节，而在 16 位系统上是 2 字节。），绝大多数时候使用 sizeof 运算符确定数据的字节数，其在编译时由编译器计算具体的字节数。

```C
double *d = (double *) malloc(sizeof(double));
```
除了类型，sizeof 还可以接收变量，但有对于指针类型一定要小心。不然就会还没开始就掉坑里了。
```C
int x[10];
int *xCopy = (int[])malloc(sizeof(x));  // 等价于 10 * sizeof(int)

int *intP = (int*)malloc(sizeof(xCopy1));     // 这里只申请了 int * 的大小，而不是 int[10].
```

另一个需要小心的地方是字符串。在为字符串声明空间时，使用以下惯用方法：`malloc(strlen(s) + 1)`，首先使用strlen()函数获取字符串的长度，并在其基础上加1，以便为字符串结束字符留出空间。在这里使用sizeof()可能会导致问题。

类型转换实际上并没有实现什么，除了告诉编译器和可能阅读你代码的其他程序员：“是的，我知道我在做什么。”通过对malloc()的结果进行类型转换，程序员只是在给予一些保证；这种类型转换对于程序的正确性并不是必需的。


当堆内存不再使用时就需要调用 free 函数进行释放。 除非申请的内存需要运行到程序结束的极少数情况，malloc 和 free 必须成对使用，否则就会出问题。**事实证明，在程序中分配内存是容易的部分；知道何时、如何以及是否释放内存才是难点。**
```
int *x = malloc(10 * sizeof(int));
...
free(x);
```
free 函数接受一个参数，即由 malloc() 返回的指针。你可能注意到，释放内存的大小并不需要传入，而必须由内存分配库本身来跟踪。


## 常见错误

### 忘记申请内存

看到标题你可能会发笑，怎么会有人忘记申请内存？但是当我说出它引起的崩溃类型你就会再也难以笑的出来了：空指针异常或者野指针。

许多函数都希望在调用前分配内存。例如， strcpy(dst, src) 函数将字符串从源地址复制到目标地址：

```C
char *src = "hello";
char *dst; // oops! unallocated
strcpy(dst, src); // segfault and die
```
这里，dst 在没有申请内存就进行拷贝，将导致段错误。在使用内存钱一定确保内存被正确申请。或者，你也可以使用 strdup() 同时完成内存申请和复制字符串。

## 没有申请足够内存

一个相关的错误是没有分配足够的内存，有时被称为缓冲区溢出。在上面的例子中，一个常见的错误是为目的地缓冲区预留几乎足够的空间。

```C
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly
```

奇怪的是，取决于 malloc 的实现方式以及其他许多细节，这个程序经常会看似正确地运行。当字符串复制执行时，它会超出分配的空间末尾一个字节，但在某些情况下这是无害的，也许是覆盖了一个不再使用的变量。一些情况下，这些溢出可能极其有害，实际上，它们是许多系统安全漏洞的源头。在其他情况下，malloc库无论如何都会分配一些额外的空间，因此你的程序实际上并没有涂鸦在其他变量的值上，并且工作得相当好。在更多的情况下，程序确实会出现故障并崩溃。因此我们学到了另一个宝贵的教训：即使它曾经正确运行过一次，并不意味着它是正确的。

## 忘记初始化内存

这种错误是，你正确地调用了 malloc()，但是忘记给给新分配的内存填入一些数据类型。不要这样做！因为这会让你的程序遇到未初始化的读取问题，即它从堆上读取一些未知的数据。谁知道那里会有什么？如果你幸运的话，这些值（例如，零）并不印象程序的正常工作。如果你不幸运，可能是一些随机且有害的数据。

## 忘记释放内存

这种错误被称为内存泄漏，它发生在忘记释放内存时。在长期运行的应用程序或系统中（比如操作系统本身），这是一个严重的问题，因为逐渐泄漏的内存最终会导致内存耗尽，到那时就需要重启。因此，通常情况下，当你完成一块内存的使用后，你应该确保释放它。请注意，使用垃圾回收语言在这里并无帮助：如果你仍然持有对某块内存的引用，没有任何垃圾回收器能释放它，即使在更现代的语言中，内存泄漏仍然是一个问题。

在某些情况下，似乎不调用 free() 是合理的。例如，你的程序生命周期很短，很快就会退出；在这种情况下，当进程结束时，操作系统会清理它分配的所有页面，因此从本质上讲不会产生内存泄漏。虽然这是“有效”的，但养成这样的习惯并不好，因此要警惕选择这种策略。从长远来看，作为程序员的的目标之一是培养好习惯；这些习惯之一就是了解内存是如何管理的，以及（在像C这样的语言中）释放你申请的内存。即使你可以不这么做，养成释放你显式分配的每一字节的习惯显然是好的。


## 在用完之前释放内存

有时，程序会在使用完内存之前就释放它；这种错误被称为悬垂指针（dangling pointer），正如你所能猜到的，它也是一个不好的事情。使用已经释放的内存可能会导致程序崩溃，或者覆盖有效的数据（例如，其它变量调用 malloc() 分配内存分到了之前被释放的内存，两个指针就指向了重合的内存）。

### 重复释放内存

程序有时也会多次释放同一块内存；这被称为双重释放（double free）。这样做的结果是非确定性的。可以想象，内存分配库可能会变得混乱并做出各种奇怪的事情；崩溃是一个常见的结果。


### 错误调用 free()

我们讨论的最后一个问题是不正确地调用 free()。毕竟，free() 期望你只传递给它之前从 malloc() 获得的指针之一。当你传递一些其他值时，坏事可能会（也确实会）发生。因此，这种无效的释放是危险的，当然应该避免。

由于内存错误频繁发生，一整套工具生态已经发展起来，以帮助你在代码中找到这类问题。可以查看 valgrind 和 ASan。

> 看到堆内存管理如此多的错误类型就知道想要管理它对于开发者负担有多重，完全避免内存错误更是不可能，即便是对于经验丰富的开发者也是如此。在上面的示例中，仅仅几行代码看起来问题很容易引起关注，经验丰富的开发者几乎是潜意识的避免出现这种错误。但是在一个复杂的系统中，多人协作、相互交互的模块、引用的三方库、特别是多线程让事情变得极其复杂，内存管理变成一个沉重的负担。

与其将如此沉重的负担留给每一个应用开发者，不如在**一个切面**上让对此有深入研究的技术人员统一处理。为了解决对内存管理的问题、技术人员想出来各种应用策略，编程语言开发者希望堆内存管理能在语言层面通过一些机制避免堆内存管理错误。

内存安全成为很多现代开发语言的一个重要目标。不同的开发语言采用了不同的策略来处理堆内存管理问题，这些策略的选择由于语言的发展历史、使用目标场景、对效率追求和安全的平衡而决定。

## 引用计数

解决对内存释放问题最简单直接的一个思路是为申请的内存添加引用计数，申请的内存块每增加一个一个引用就加一，一个引用被销毁就减一，当引用数量为 0 时就释放内存。

例如 Swift 语言的编译器会直接在对象本省中插入用于计数的变量，在

```Swift
class Persion {
    var age = 10
}

var lilei = Persion()
var shadow = lilei
```
编译器会自动位对象添加引用计数的空间，此外对象中还有类型信息。类型信息区域在 32bit 的机子上是 4byte，在 64bit 机子上是 8 byte。引用计数占用 8 byte。所以，在堆上，类属性的地址是从第 16 个字节开始的。

```
+-----------+
| meta data | 4/8 bytes
+-----------+
| ref count |  8  bytes
+-----------+
|    ...    |
+-----------+
```
并在变量赋值时插入代码增加引用计数。在变量销毁时插入减少计数的代码。

> 扩展：swift 没有直接提供控制在堆还是栈上申请空间的方式。对于结构体，变量是在栈上分配空间，而类是引用类型，定义变量会在堆上申请空间。这种实现方式对于应用开发这种内存不敏感的领域影响不大，但对于操作系统和嵌入式来说是不可接受的，因为在在对上分配对象需要额外的空间，显然不可接受。除非提供其它方式，否则对于很难用于开发操作系统。

对于 C++ 这种历史久远同时强调兼容 C 的语言来说，无法在像现代语言一样在开发人员无感的情况下通过编译器插入代码来处理堆内存管理。不得不采用另一种方式：智能指针。

```

```

引用计数简单直接，但也有一些限制。循环引用时，由于引用计数不会变为 0，就不会被释放。例如，a 应用了 b，b 引用了 a，此时 a 和 b 的引用计数都是 1，这时候就需要主动解除引用才能释放对象。对于

## 所有权


## 垃圾回收





***在了解内存管理的不同处理时，我们需要留意一个明显的特点，即：软件开发中通常将一类问题统一处理。将这些棘手的问题统一处理有很多好处：1. 术业有专攻，统一处理能有专业的研究人员找到更合适的方案，甚至在在后期优化后可以在开发人员无感的情况下得到升级应用。2. 统一处理能得到更广泛的测试，避免了（至少是减少）了问题出现。3。集中处理避免每个人都需要处理相同的问题，减轻其开发者的负担，让应用开发者专注于业务逻辑。***



正确的内存管理一直是一个如此棘手的问题，以至于许多新的语言都支持自动内存管理。在这样的语言中，当你调用类似于 malloc() 的函数来分配内存（通常是 new 或类似的函数来分配一个新对象）时，你永远不需要调用任何东西来释放空间；相反，垃圾回收器会运行并确定你不再引用的内存，并为你释放它。
