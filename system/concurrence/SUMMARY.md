# 总结对比

## 进程和线程的详细区别

进程有父进程和子进程关系，但是线程没有父子关系。

进程无父子关系，各个进程是独立的。
线程有父子关系，父线程终止，全部子线程被迫终止(没有了资源)。子线程终止不会影响父线程。
谁说的对？

不同于进程的严格父子层次关系组织，一个进程内的线程组成一个线程对等池。对等影响是，一个线程可以杀死任意的线程，或者等待其结束。每个对等线程都可以读写共享的数据。


## 进程能不创建线程吗？

计算机硬件不区分什么是进程，什么是线程，只是运行的片段。进程和线程是操作系统的概念，在没有线程支持系统上，调度单位是进程。在以线程为调度单位的现代 OS 上，其进程的执行部分就是线程，也即主线程。
以 Linux 为例，其进程和线程都是同一个数据结构：

```C
struct task_struct {
    ...
	pid_t				pid;
	pid_t				tgid; //thread group id
    ...
}
```

Linux 2.6 开始实现 NPTL 模型的线程。 task_struct 结构中增加了一个tgid(thread group id)字段，表示线程组。

从内核的角度看，每个线程都有自己的 ID, 使用的是 pid 字段（个人猜测是因为历史原因，Linux 2.6 之前线程的实现的是 LWP(轻量级进程)，也即每个线程都一个进程在调度，使用的是进程 ID.），其实命名为 tid 更合适。而进程 ID 则使用 tgid 字段。如果一个进程是主进程时，其 `pid` 等于 `tgid`。

```
// https://stackoverflow.com/questions/9305992/if-threads-share-the-same-pid-how-can-they-be-identified

                         USER VIEW
                         vvvv vvvv
              |
<-- PID 43 -->|<----------------- PID 42 ----------------->
              |                           |
              |      +---------+          |
              |      | process |          |
              |     _| pid=42  |_         |
         __(fork) _/ | tgid=42 | \_ (new thread) _
        /     |      +---------+          |       \
+---------+   |                           |    +---------+
| process |   |                           |    | process |
| pid=43  |   |                           |    | pid=44  |
| tgid=43 |   |                           |    | tgid=42 |
+---------+   |                           |    +---------+
              |                           |
<-- PID 43 -->|<--------- PID 42 -------->|<--- PID 44 --->
              |                           |
                        ^^^^^^ ^^^^
                        KERNEL VIEW
``` 



每个 task_struct 的 pid 都不同。所以从内核调度来看，线程和进程没什么区别。

参考 [Linux的进程和线程的现状及其发展史简述](https://www.cnblogs.com/yudidi/p/12417285.html)
[](https://blog.csdn.net/adcxf/article/details/3940982)


> 为什么仍然有人坚称 Linux 的内核没有线程的概念，内核调度是是进程，而不是线程？

个人观点：Linux 实现了线程。
原因：
线程还是进程，都是认为规定的概念，首先看下定义：进程是资源分配的基本单位，线程是调度的基本单位。Linux 没有在一诞生就实现多线程，实际上任何系统也不可能一诞生就是功能完备的。早起确实 Linux 只有进程，因此调度的也是进程。在实现线程的过程中，Linux 简化了实现，首先是用轻量级进程（LWP）实现的。所以后来 NPTL 实现，仍有人按照原来的说法，认为内核调度的是轻量级进程，而且 Linux 仍然沿用了 task_struct 的数据结构。但是首先要说明的是，数据结构不是能代表它是线程还是进程，而是人们对于线程和进程的定义：”进程是资源分配的基本单位“，当一个程序加载进内存，创建 task_struct 并分配地址空间，则它是一个进程。在程序进入调度，开始运行，则它是一个线程。因为“线程是调度的基本单位”。

另一个支持 Linux 只有进程的说法是：不是只有线程可以调度，进程也是可以调度的。这个我是同意的，因为在没有线程的系统上，进程确实是调度的基本单位，这也是早起 Linux 的实现方式。然而，这很容易反驳，线程是空闲资源的，根本就是共享内存空间。如果创建一个 task_struct，它跟已有的 task 共享了内存空间，那它就共享资源，也即创建的是一个线程。


Linux 的进程和线程同时用一个数据结构表示，完全不违反任何概念，没有谁说进程和线程是完全独立，不可相连的。而使用同一数据结构有其历史原因（历史上实现的进程调度），也有其 KISS 的设计理念，使整个系统的实现变得简单。


## 为什么线程比进程高效？

从 Linux 的实现上看，进程和线程都使用了同样的数据结构。而任务的切换都是保存执行现场（寄存器的内容），看起来两者的代码是一样的，为什么常听说线程比进程更高效？哪里高效？

要比较两者的效率，需要从两方面来比较：

- 创建
- 调度

1. 用户空间的信息，地址空间
2. 内核空间 PCB

线程的上下文要比进程的上下文小得多，线程上线文切换要比进程上下文切换快的多。（对吗？我看进程和线程的任务都是用 Task 表示的，切换代码一样。真正影响速度的是进程地址空间不一样导致的缓存失效。）

### 创建

### 为什么线程调度比进程调度轻量？

支持多线程的系统，即便是多进程，调度的单位也是线程，那为什么线程要比进程高效？

1. 创建开销
2. 调度开销（调度时，线程和进程都是指针切换，都是要保存寄存器的状态，为什么说线程比进程高效？）


线程切换不需要更换页表，而进程切换需要。
页表切换缓存失效，性能低

进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小

2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。
