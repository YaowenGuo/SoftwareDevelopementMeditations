# concurrence

A logical flow whose execution overlaps in time with another flow is called a concurrent flow, and the two flows are said to run concurrently. The general phenomenon of multiple flows executing concurrently is known as concurrency. 

Notice that the idea of concurrent flows is independent of the number of processor cores or computers that the flows are running on. If two flows overlap in time, then they are concurrent, even if they are running on the same processor. However, we will sometimes find it useful to identify a proper subset of concurrent flows known as parallel flows. If two flows are running concurrently on different processor cores or computers, then we say that they are parallel flows, that they are running in parallel, and have parallel execution.

并发在计算机的不同层次上都有体现。硬件异常处理、进程、进程的信号处理都是常见的示例。在操作系统内核中并发是运行多个应用的一种机制。但是并发的应用不仅限于内核中。它在应用编程中也扮演着重要的角色。例如：在应用运行过程中信号处理可以处理并发事件例如用户输入 Type+C 以及程序访问虚拟内存未定义的区域。应用级的并发在其它方面也很有用：


- **访问缓慢的 I/O 设备。**当应用在等待数据从缓慢的的 I/O 设备加载时（例如磁盘），内核会通过运行其他进程来利用 CPU 资源。单个应用程序也可以通过将有用的工作与 I/O 请求重叠，以类似的方式利用并发性。

- **与人交互。**与计算机交互的人需要同时执行多项任务的能力。例如，他们可能希望在打印文档时调整窗口的大小。现代窗口系统使用并发性来提供此功能。每次用户请求某些操作(例如，通过单击鼠标)时，将创建一个单独的并发逻辑流来执行该操作。

- **通过推迟工作来减少延迟。** 有时，应用程序可以使用并发性来延迟其他操作并并发地执行它们，从而减少某些操作的延迟。例如，动态存储分配器可以减少独立的释放操作的延迟。通过将其合并到低优先级的并发的回收流，以便在 CPU 空闲时再使用。

- **服务多个网络客户端。** 对于一个真实服务器，可以每秒服务数百或数千个客户端。通过并发将连接独立运行，可以防止慢速客户端独占服务器。

- **在多核机器上并行计算。**许多现代系统都配备了包含多个 CPU 的多核处理器。被划分为并发流的应用程序通常在多核机器上比在单处理器机器上运行得更快，因为流是并行执行的，而不是交错执行的。


使用应用级并发的程序被称为并发应用。现代操作系统为构建并发程序提供了三种基本方法：

- **进程。**通过这种方法，每个逻辑控制流都是一个由内核调度和维护的过程。由于进程具有单独的虚拟地址空间，想要相互通信的流必须使用某种显式进程间通信（IPC）机制。

- **I/O 多路复用。**：应用程序在单个进程的上下文中明确安排自己的逻辑流。逻辑流被建模为状态机，随着数据到达文件描述符，主程序随着在状态间转换。由于程序是单个进程，所以所有流共享相同的地址空间。

- **线程。**线程是在单个进程的上下文中运行的逻辑流，并由内核调度。您可以将线程视为其他两种方法的混合体，像进程一样由内核调度，像 I/O多路复用一样共享相同的虚拟地址空间。

此外，在应用层级，某些语言或者库还提供了协程。
- 协程：根据是否有栈分为有栈协程与无栈协程。无栈协程本质就是一个状态机，因为没有栈就无法保存函数调用的局部数据（简单的函数被编译器转化为状态跳转），因此无法实现复杂的功能、功能受限。因此普遍流程的协程都是有栈协程（将在堆上申请空间用于保存栈数据的也归为此类）。协程的实现各有不同，但都需要基于底层系统的提供的能力来实现。因为系统并没有协程的概念，所有的协程其实都是运行在线程之上的。其也具有线程的一些特性。


除了进程是使用单独的地址空间，其它都在一个进程中，使用相同的地址空间。


区别：

- 进程

- I/O 多路复用

- 线程

- 协程


##  进程与线程

进程和线程的区别，就像雷锋和雷锋塔，或者 Java 和 JavaScript 不能说毫无关系，只能说关系不大。要理解两者的区别，从其原先的英语名字能更好的理解。毕竟其发明者的母语是英语。

进程: Process

是对处理器 Processor 的抽象。在早期的计算机上只能运行一个程序，它占有这个 CPU 全部内存空间和资源。一次只能运行一个程序无法满足人们的想要处理多个任务的需求。为了完成在同一台计算同时运行多个程序的目的，将运行的程序抽象为一个进程，CPU 通过快速的切换这些进程，表现的像多个程序同时运行的样子。对于这些程序来说，它们好像独占了 CPU，并不知道有其他程序在同一 CPU 上运行，所谓独占就是整个地址空间都是它自己的，比如 32 为计算机的地址是 0 ~ 4G，这所有的地址它都可以访问的。

由于每个进程都有独立的地址空间，一个进程不可能直接能访问到另一个进程中的内容，也即资源，这也是为什么说进程是分配资源的基本单位。

关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。


线程: Thread

从名字看出来 Thread 和 Process 完全是两个概念。在一个程序内部（也就是一个进程）也有同时运行多个任务的需求，例如在一个音乐软件，即便播放音乐，还要能让人继续浏览其他的内容。并发的任务，其实就是并发执行的多个程序片段。为了在同一软件中同时执行多个任务，计算机研究的先驱为了抽象这种同时执行的程序，提出了 Thread 的概念。由于这些线程在同一个程序内，他们共享地址空间。这也是他们共享资源的根本原因，直接可以通过地址访问到当前进程的任何资源。


进程是60年代初首先由麻省理工学院的 MULTICS 系统和 IBM 公司的CTSS/360系统引入的。

80年代，出现了能独立运行的基本单位——线程（Threads）



### QA

1. 多核处理器是有多个时钟中断吗？如果只有一个，是所有的运行的核都停止运行吗？

2. 如果系统正在运行，发生了时钟中断怎么办？

- 协程编程模型更好？
- 协程能够取代线程？
- 为什么系统不引入协程？
- 多个线程的实际堆栈是怎样的？

> 如何达到最好的运行效率？

协称是在线程之上的，它怎么就比线程高效了？多少个线程能在单个系统上达到最高的运行效率？

线程切换的效率，当线程少的时候，是否能独占系统，不用切换？
当线程多的时候，是否效率会变化？切换的时间片是否根据线程数量改变？