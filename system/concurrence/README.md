# concurrence

A logical flow whose execution overlaps in time with another flow is called a concurrent flow, and the two flows are said to run concurrently. The general phenomenon of multiple flows executing concurrently is known as concurrency. 

Notice that the idea of concurrent flows is independent of the number of processor cores or computers that the flows are running on. If two flows overlap in time, then they are concurrent, even if they are running on the same processor. However, we will sometimes find it useful to identify a proper subset of concurrent flows known as parallel flows. If two flows are running concurrently on different processor cores or computers, then we say that they are parallel flows, that they are running in parallel, and have parallel execution.

并发是现代计算机一个热度极高的话题，之前并发是由时间片轮转来模拟的。随着计算机的发展，多核 CPU 得到普及，已经深刻改变了并发的内部，现在并发的任务可以在同一 CPU 的不同内核上做到真正的并行执行。

使用应用级并发的程序被称为并发应用。现代操作系统为构建并发应用提供了三种基本方式：

- 进程

- I/O 多路复用：应用程序在单个进程的上下文中明确安排自己的逻辑流。逻辑流被建模为状态机，随着数据到达文件描述符，主程序随着在状态间转换。
- 线程

此外，在应用层级，某些语言或者库还提供了协程。
- 协程

除了进程是使用单独的地址空间，其它都在一个进程中，使用相同的地址空间。





##  进程与线程

进程和线程的区别，就像雷锋和雷锋塔，或者 Java 和 JavaScript 不能说毫无关系，只能说关系不大。要理解两者的区别，从其原先的英语名字能更好的理解。毕竟其发明者的母语是英语。

进程: Process

是对处理器 Processor 的抽象。在早期的计算机上只能运行一个程序，它占有这个 CPU 全部内存空间和资源。一次只能运行一个程序无法满足人们的想要处理多个任务的需求。为了完成在同一台计算同时运行多个程序的目的，将运行的程序抽象为一个进程，CPU 通过快速的切换这些进程，表现的像多个程序同时运行的样子。对于这些程序来说，它们好像独占了 CPU，并不知道有其他程序在同一 CPU 上运行，所谓独占就是整个地址空间都是它自己的，比如 32 为计算机的地址是 0 ~ 4G，这所有的地址它都可以访问的。

由于每个进程都有独立的地址空间，一个进程不可能直接能访问到另一个进程中的内容，也即资源，这也是为什么说进程是分配资源的基本单位。

关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。


线程: Thread

从名字看出来 Thread 和 Process 完全是两个概念。在一个程序内部（也就是一个进程）也有同时运行多个任务的需求，例如在一个音乐软件，即便播放音乐，还要能让人继续浏览其他的内容。并发的任务，其实就是并发执行的多个程序片段。为了在同一软件中同时执行多个任务，计算机研究的先驱为了抽象这种同时执行的程序，提出了 Thread 的概念。由于这些线程在同一个程序内，他们共享地址空间。这也是他们共享资源的根本原因，直接可以通过地址访问到当前进程的任何资源。


进程是60年代初首先由麻省理工学院的 MULTICS 系统和 IBM 公司的CTSS/360系统引入的。

80年代，出现了能独立运行的基本单位——线程（Threads）

## 进程和线程的详细区别

进程有父进程和子进程关系，但是线程没有父子关系。

进程无父子关系，各个进程是独立的。
线程有父子关系，父线程终止，全部子线程被迫终止(没有了资源)。子线程终止不会影响父线程。
谁说的对？


## 进程能不创建线程吗？

计算机硬件不区分什么是进程，什么是线程，只是运行的片段。进程和线程是操作系统的概念，在没有线程支持系统上，调度单位是进程。在以线程为调度单位的现代 OS 上，其进程的执行部分就是线程，也即主线程。
以 Linux 为例，其进程和线程都是同一个数据结构：

```C
struct task_struct {
    ...
	pid_t				pid;
	pid_t				tgid; //thread group id
    ...
}
```

Linux 2.6 开始实现 NPTL 模型的线程。 task_struct 结构中增加了一个tgid(thread group id)字段，表示线程组。

从内核的角度看，每个线程都有自己的 ID, 使用的是 pid 字段（个人猜测是因为历史原因，Linux 2.6 之前线程的实现的是 LWP(轻量级进程)，也即每个线程都一个进程在调度，使用的是进程 ID.），其实命名为 tid 更合适。而进程 ID 则使用 tgid 字段。如果一个进程是主进程时，其 `pid` 等于 `tgid`。

```
// https://stackoverflow.com/questions/9305992/if-threads-share-the-same-pid-how-can-they-be-identified

                         USER VIEW
                         vvvv vvvv
              |
<-- PID 43 -->|<----------------- PID 42 ----------------->
              |                           |
              |      +---------+          |
              |      | process |          |
              |     _| pid=42  |_         |
         __(fork) _/ | tgid=42 | \_ (new thread) _
        /     |      +---------+          |       \
+---------+   |                           |    +---------+
| process |   |                           |    | process |
| pid=43  |   |                           |    | pid=44  |
| tgid=43 |   |                           |    | tgid=42 |
+---------+   |                           |    +---------+
              |                           |
<-- PID 43 -->|<--------- PID 42 -------->|<--- PID 44 --->
              |                           |
                        ^^^^^^ ^^^^
                        KERNEL VIEW
```



每个 task_struct 的 pid 都不同。所以从内核调度来看，线程和进程没什么区别。

参考 [Linux的进程和线程的现状及其发展史简述](https://www.cnblogs.com/yudidi/p/12417285.html)
[](https://blog.csdn.net/adcxf/article/details/3940982)


> 为什么仍然有人坚称 Linux 的内核没有线程的概念，内核调度是是进程，而不是线程？

个人观点：Linux 实现了线程。
原因：
线程还是进程，都是认为规定的概念，首先看下定义：进程是资源分配的基本单位，线程是调度的基本单位。Linux 没有在一诞生就实现多线程，实际上任何系统也不可能一诞生就是功能完备的。早起确实 Linux 只有进程，因此调度的也是进程。在实现线程的过程中，Linux 简化了实现，首先是用轻量级进程（LWP）实现的。所以后来 NPTL 实现，仍有人按照原来的说法，认为内核调度的是轻量级进程，而且 Linux 仍然沿用了 task_struct 的数据结构。但是首先要说明的是，数据结构不是能代表它是线程还是进程，而是人们对于线程和进程的定义：”进程是资源分配的基本单位“，当一个程序加载进内存，创建 task_struct 并分配地址空间，则它是一个进程。在程序进入调度，开始运行，则它是一个线程。因为“线程是调度的基本单位”。

另一个支持 Linux 只有进程的说法是：不是只有线程可以调度，进程也是可以调度的。这个我是同意的，因为在没有线程的系统上，进程确实是调度的基本单位，这也是早起 Linux 的实现方式。然而，这很容易反驳，线程是空闲资源的，根本就是共享内存空间。如果创建一个 task_struct，它跟已有的 task 共享了内存空间，那它就共享资源，也即创建的是一个线程。


Linux 的进程和线程同时用一个数据结构表示，完全不违反任何概念，没有谁说进程和线程是完全独立，不可相连的。而使用同一数据结构有其历史原因（历史上实现的进程调度），也有其 KISS 的设计理念，使整个系统的实现变得简单。


## 为什么线程比进程高效？

从 Linux 的实现上看，进程和线程都使用了同样的数据结构。而任务的切换都是保存执行现场（寄存器的内容），看起来两者的代码是一样的，为什么常听说线程比进程更高效？哪里高效？

要比较两者的效率，需要从两方面来比较：

- 创建
- 调度

### 创建

### 为什么线程调度比进程调度轻量？

支持多线程的系统，即便是多进程，调度的单位也是线程，那为什么线程要比进程高效？

1. 创建开销
2. 调度开销（调度时，线程和进程都是指针切换，都是要保存寄存器的状态，为什么说线程比进程高效？）


线程切换不需要更换页表，而进程切换需要。
页表切换缓存失效，性能低

进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小

2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。


协程编程模型更好？
协程能够取代线程？
为什么系统不引入协程？
多个线程的实际堆栈是怎样的？


> 如何达到最好的运行效率？

协称是在线程之上的，它怎么就比线程高效了？多少个线程能在单个系统上达到最高的运行效率？

线程切换的效率，当线程少的时候，是否能独占系统，不用切换？
当线程多的时候，是否效率会变化？切换的时间片是否根据线程数量改变？


### 线程上下文

一个整数线程 ID
栈
栈指针
程序计数器
通用目的的寄存器和条件码？


与同一进程中的其它线程共享整个进程的虚拟地址空间
包括代码、数据区域、堆、共享库、和打开的文件。

线程的上下文要比进程的上下文小得多，线程上线文切换要比进程上下文切换快的多。
不同于进程的严格父子层次关系组织，一个进程内的线程组成一个线程对等池。对等影响是，一个线程可以杀死任意的线程，或者等待其结束。每个对等线程都可以读写共享的数据。

**寄存器是从不共享的，而虚拟存储器总是共享的**




### QA

1. 多核处理器是有多个时钟中断吗？如果只有一个，是所有的运行的核都停止运行吗？

2. 如果系统正在运行，发生了时钟中断怎么办？

3. 