# 堆与堆上内存对象管理

这里只关注语言层面上对堆上对象的管理，而不深入堆内存是如何分配和的。

操作系统对于硬件的抽象，将其抽象暴露给应用开发者更简单的概念：
- 内存管理
- 设备管理：文件
- CPU 管理：抽象为进程

在所有硬件中，内存是系统暴露底层给开发者最多的。而内存又是开发中最普遍的存在，内存对于程序犹如空气之于人类。虽然关注不多，却是无处不在。

在应用开发应用的内存概念中，堆内存是最容易出问题的地方，因为这部分内存留给开发者管理，这就导致对其的使用完全取决于开发者的经验和技术水平。在一个复杂系统中，即使经验丰富的开发者也不能保证堆内存使用完全没有任何问题。为了解决这部分问题，语言想要将这部分内存管理的任务接管过来，减轻开发者的负担，尽力保证程序开发的程序质量。对于堆上内存管理，目前有三种方案：

1. 垃圾回收：这需要语言独立运行一个垃圾回收器。代表就是 Java.
2. 引用计数：代表就是 Swift。编译器会在对象生成是为对象增加计数，在出作用域时插入代码检查计数，计数为 0 就回收对象的内存。
3. 所有权：只允许一个引用持有对象，在引用出作用域时释放内存。


## C++

C++ 早期历史上没有内存管理的概念，在 C++11 增加了智能指针来管理内存。




## Rust

Rust 中最常见的指针类型是引用。引用由&符号表示，并借用它们所指向的值。其除了引用数据之外，没有什么特别的能力。而且，它没有任何开销，是我们最常用的指针类型。

智能指针，不仅充当指针而且还具有额外的元数据和功能的数据结构。

引用计数智能指针类型

指针和引用：

- 引用是指只借用数据的指针;相反，在许多情况下，智能指针拥有它们所指向的数据。

- 智能指针通常使用 struct 实现。智能指针与普通结构的区别在于智能指针实现了 Deref 和 Drop 特征。Deref特征允许智能指针的实例的行为类似于引用，以是你可以任意使用引用或智能指针的方式访问数据。Drop trait 用于自定义当智能指针的实例超出作用域时运行的代码。
