# Annotation


Java 使用 `public @interface ButterKnife` 生成一个注解。 Kotlin 使用关键字 `annotation` 来标注 `class` 用于生成注解。

反射来获取对象比较重，每次获取都要遍历方法，比较影响性能。而使用　Annotation Processtor 相比较反射性能更好。虽然它使用的也是反射，但是它并不会随着变量增多而线性增加遍历，所以影响性能较小。

Annotation Processtor　不是在运行时读反射获取注解，而是在编译前（也不是编译的时候）就读取注解，根据注解的内容生成代码。然后这部分代码和写的代码一块编译。属于预处理的一部分。由于在编译前就生成了

## Butter Knife 是依赖注入吗？

依赖注入的关键是，变量的值是由外部决定的，在创建对象的时候，由外部赋值给对象的内部变量，例如一个对象的构造器传入的参数赋值的变量是有外部注入的。

```
class Test(var userName: String, var age: Int)

```

userName 和 age 的值在创建的时候，有外部传入，是一种注入。


## 元注解

Java 四个元注解，用于标识其他注解。用于生成注解的注解有

- @Retention 标记注解的作用范围，从短到长为：
    - SOURCE：仅在源码层面上有效
    - CLASS: 从源码到字节码都有效
    - RUNTIME: 从源码到运行时都有效
- @Target: 注解使用的目标的类型，是注解类还是变量、方法、参数等。
    - TYPE: 类，接口
    - FIELD: 变量
    - METHOD: 方法
    - PARAMETER: 参数
    - CONSTRUCTOR: 构造器
- @Documented : 将此内容包含在 Javadoc 中
- @Inherited: 允许子类继承父类中的注解



## 注解参数

注解参数就是注解接口中的方法，类型就是方法的返回类型。当方法名为 `value` 时，可以不在注解时写成 `变量 = 值`，而可以只写要传入的值。


## Annatation Process Tool 生成代码的流程


## 代理区别

静态代理和动态代理的区别
代理：结构型设计模式，主要解决的问题是：在直接访问对象时带来的问题

按照代理的创建时期，代理类可以分为两种： 

静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。

动态：在程序运行时运用反射机制动态创建而成。(InvocationHandler 的应用)

静态代理缺点：

1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。

2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。





