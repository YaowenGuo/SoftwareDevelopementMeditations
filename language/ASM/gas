One of the major ways you’ll end up learning many of the standard C library calls is by using them in short C programs and then inspecting the .s assembly output files that gcc generates. Having some ability to read AT&T mnemonics can be useful while you’re getting comfortable with C calling conventions.

##AT&T Mnemonic Conventions

    If you’re going to deal with the standard C library and the multitudes of other function libraries written in C and for C, it makes sense to become at least passingly familiar with the AT&T mnemonics. There are some general rules that, once digested, make it much easier. Here’s the list in short form:

######AT&T mnemonics and register names are invariably lowercase.

    This is in keeping with the Unix convention of case sensitivity. I’ve mixed uppercase and lowercase in the text and examples to get you used to seeing assembly source both ways, but you have to remember that while Intel (and hence NASM) suggest uppercase but will accept lowercase, AT&T requires lowercase.

######Register names are always preceded by the percent symbol, %.

    That is, what Intel would write as AX or EBX, AT&T would write as %ax and %ebx . This helps the assembler recognize register names. Every AT&T machine instruction mnemonic that has operands has a single-character suffix indicating how large its operands are. The suffix letters are b, w, and l, indicating byte (8 bits), word (16 bits), or long (32 bits). What Intel would write as MOV BX , AX , AT&T would write as movw %ax , %bx . (The changed order of %ax and %bx is not an error. See the next rule!)

######In the AT&T syntax, source and destination operands are placed in the opposite order from Intel syntax.

    That is, what Intel would write as MOV BX , AX , AT&T would write as movw %ax , % bx. In other words, in AT&T syntax, the source operand comes first, followed by the destination.

######In the AT&T syntax, immediate operands are always preceded by the dollar sign ($).

    What Intel would write as PUSH 32 , AT&T would write as pushl $32. This helps the assembler recognize immediate operands.

######Not all AT&T instruction mnemonics are generated by gcc.

    Equivalents to Intel’s JCXZ , JECXZ , LOOP , LOOPZ , LOOPE , LOOPNZ , and LOOPNE have only recently been added to the AT&T mnemonic set, and gcc never generates code that uses them.

######In the AT&T syntax, displacements in memory references are signed quantities placed outside parentheses containing the base, index, and scale values.

######When an instruction does not take operands ( call , leave , ret ), it does not have an operand-size suffix. Calls and returns look pretty much alike in both Intel and AT&T syntax.

######When referenced, the name of a message string is prefixed by a dollar sign ($), just as numeric literals are. In NASM, a named string variable is considered a variable and not a literal. This is just another AT&T peccadillo to be aware of.

######Note that the comment delimiter in the AT&T scheme is the pound sign (#), rather than the semicolon used in nearly all Intel-style assemblers, including NASM.






    The dateis.c program shown below get a sense for how ctime() was called at the assembly level. You don’t automatically get an .s file every time you compile a C program. The .s file is created, but once gas assembles the .s file to a binary object code file (typically an .o file), it deletes the .s file. If you want to examine an .s file created by gcc, you must compile with the – S option. (Note that this is an uppercase S. Case matters in the Unix world!) The command looks like this:

gcc dateis.c –S

    If you specify the – S option, gcc understands that you want to generate assembly source, rather than an executable program file, so it generates only the .s file. To compile a C program to an executable program file, you must compile it again without the – S option.

    Here’s dateis.c, which does nothing more than print out the date and time as returned by the standard C library function ctime() :

```

#include <time.h>

#include <stdio.h>

int main()

{

    time_t timeval;

    (void)time(&timeval);

    printf(“The date is: %s“, ctime(&timeval));

    exit(0);

}

```

    When gcc compiles the preceding program (dateis.c), it produces the file dateis.s, shown in Listing 12-4. I have manually added the equivalent Intel mnemonics as comments to the right of the AT&T mnemonics, so you can see what equals what in the two systems. (Alas, neither gcc nor any other utility I have ever seen will do this for you.)

```

	.file	"dateis.c"

	.section	.rodata

.LC0:

	.string	"The date is: %s"

	.text

	.globl	main

	.type	main, @function

main:

.LFB0:

	.cfi_startproc

	leal	4(%esp), %ecx

	.cfi_def_cfa 1, 0

	andl	$-16, %esp

	pushl	-4(%ecx)

	pushl	%ebp

	.cfi_escape 0x10,0x5,0x2,0x75,0

	movl	%esp, %ebp

	pushl	%ecx

	.cfi_escape 0xf,0x3,0x75,0x7c,0x6

	subl	$20, %esp

	movl	%gs:20, %eax

	movl	%eax, -12(%ebp)

	xorl	%eax, %eax

	subl	$12, %esp

	leal	-16(%ebp), %eax

	pushl	%eax

	call	time

	addl	$16, %esp

	subl	$12, %esp

	leal	-16(%ebp), %eax

	pushl	%eax

	call	ctime

	addl	$16, %esp

	subl	$8, %esp

	pushl	%eax

	pushl	$.LC0

	call	printf

	addl	$16, %esp

	movl	$0, %eax

	movl	-12(%ebp), %edx

	xorl	%gs:20, %edx

	je	.L3

	call	__stack_chk_fail

.L3:

	movl	-4(%ebp), %ecx

	.cfi_def_cfa 1, 0

	leave

	.cfi_restore 5

	leal	-4(%ecx), %esp

	.cfi_def_cfa 4, 4

	ret

	.cfi_endproc

.LFE0:

	.size	main, .-main

	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.1) 5.4.0 20160609"

	.section	.note.GNU-stack,"",@progbits

```

##AT&T Memory Reference Syntax

	The AT&T syntax for memory addressing is considerably different. In place of square brackets, AT&T mnemonics use parentheses to enclose the components of a memory address:

	movb (%ebx),%al 	# mov byte al,[ebx] in Intel syntax

	Here, we’re moving the byte quantity at [ebx] to AL. Inside the parentheses you place the base, the index, and the scale, when present. (The base must always be there.) The displacement, when one exists, must be placed in front of and outside the parentheses:

	movl –4(%ebx),%eax 		# mov dword eax,[ebx-4] in Intel syntax

	movb 28(%ebx,%edi),%eax # mov byte eax,[ebx+edi+28] in Intel syntax

	Note that in AT&T syntax, you don’t do the math inside the parentheses. The base, index, and scale are separated by commas, and plus signs and asterisks are not allowed. The schema for interpreting an AT&T memory reference is as follows:

	±disp(base,index,scale)

	The ± symbol I use in the preceding schematic example indicates that the displacement is signed; that is, it may be either positive or negative, to indicate whether the displacement value is added to or subtracted from the rest of the address.Typically, you only see the sign as explicitly negative; without the minus symbol, it is assumed that the displacement is positive. The displacement and scale values are optional.

	What you will see most of the time, however, is a very simple type of memory reference:

	-16(%ebp)
