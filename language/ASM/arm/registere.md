# 寄存器

常用的寄存器缩写：
```
R：Register；寄存器
PC：Program Counter；程序计数器
CPSR：Current Program Status Register；当前程序状态寄存器
SPSR：Saved Program Status Register；保存的程序状态寄存器
SP：Stack Pointer；数据栈指针
LR：Link Register；连接寄存器，return 要返回到的地址。
SB：静态基址寄存器
SL：数据栈限制指针
FP：帧指针
IP：Intra-Procedure-call Scratch Register；内部程序调用暂存寄存器
```

ARM共有37个寄存器，可以工作在7种不同的模式。以下根据上图进行分类的说明：

<待添加图片>


[寄存器](https://blog.csdn.net/weixin_42135087/article/details/111263720)

ARM32 的寄存器
![ARM32 Register](images/register)

在 armv7 上PC是一个通用寄存器R15，在armv8上 PC 不再是一个寄存器，它不能直接被修改。必需使用一些隐式的指令来改变，如 PC-relative load

ARM64汇编中有 34 个寄存器，其中包含 31 个通用寄存器(x0-x30)，SP，PC 和 PST。其中 X29 用作 FP 寄存器 x30 用作 LR 寄存器:
```
FP = X29
LR = X30
```
在实际的编译器中，X29 一般作为一个通用寄存器而不是一个栈帧指针，栈帧只在调试程序时需要解析栈的时候有用，对实际的程序运行没有什么影响。有了返回地址 LR 和栈指针 SP 就能进行程序调用。因此编译器为了优化性能和栈空间，通常不会保存 FP。在 Android 的崩溃输出中也是这样：

```
Cause: null pointer dereference
    x0  b400007a60700260  x1  0000000000000001  x2  0000000000000110  x3  0000000000000003
    x4  0000000000000111  x5  b400007a60700370  x6  ff6b6b746d1f7268  x7  7f7f7f7f7f7f7f7f
    x8  00000078089b6730  x9  00000078089b7a58  x10 000000000000001a  x11 fffffffffffffffd
    x12 0000007fd8927e90  x13 0000000000000010  x14 b400007a6070025f  x15 000005e71afb4c3e
    x16 00000078089b69c0  x17 0000007b14c5ea40  x18 0000007b39082000  x19 0000000000000001
    x20 b400007a60700250  x21 b4000079706fb7b8  x22 000000780d29a00a  x23 000000000000106e
    x24 000000787f381100  x25 0000007fd8929710  x26 0000000010380004  x27 000000000000000c
    x28 0000007fd8929600  x29 0000007fd8929540
    lr  00000078089b1c80  sp  0000007fd8929540  pc  0000007b14c5eb20  pst 00000000a0001000
```


通用寄存器x0-x30有64bit, 如果用不到64位，可以用低位的32位(w0-w30), 也就是说x0和w0本质上是一个寄存器，只是利用的位数不一样而已。

其中还有一个零寄存器 `xzr`。xzr/wzr分别表示64/32位，其做用就是0，写进去表明丢弃结果，读出来是0。

前面0~30个通用寄存器的访问方式有2种：

- 当将其作为 32bit 寄存器的时候，使用 W0 ~ W30 来引用它们。（数据保存在寄存器的低32位）
- 当将其作为 64bit 寄存器的时候，使用 X0 ~ X30 来引用它们。

第31个专用寄存器的访问方式有4种:

- 当将其作为 32bit 栈帧指针寄存器（stack pointer) 的时候，使用 WSP 来引用它。
- 当将其作为 62bit 栈帧指针寄存器（stack pointer) 的时候，使用 SP 来引用它。
- 当将其作为 32bit 零寄存器( zero register )的时候，使用 WZR 来引用它。
- 当将其作为 62bit 零寄存器( zero register )的时候，使用 ZR 来引用它。

另外需要注意的，像 FP (X29), LR（X30) 寄存器都不能和 SP(x31) 寄存器一样用名字来访问，而只能使用数字索引来访问它们。

其实还有第32个专用寄存器，它就是 PC (x32）寄存器，但是在ARM的汇编文档里面说明了，你无法在汇编中使用 PC 名称的方式或者用 X32 数字索引的访问它，因为它不是给汇编用的，而是给CPU执行汇编指令时用的，它永远记录着当前CPU正在执行哪一句指令的地址。



## 特殊寄存器

WZR/XZR
寄存器r31是一个特殊的寄存器：
Zero Register: 在大多数情况下，作为源寄存器使用时， r31读出来的值 是0; 作为目标寄存器使用时， 丢弃结果。 WZR(word zero rigiser)或者XZR(64位）

```assembly
mov	w0, wzr
``` 
