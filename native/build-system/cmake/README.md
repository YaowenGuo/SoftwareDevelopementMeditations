# CMake

CMake 是一个元构建系统，即用于生成其他构建系统的软件。元构建系统并不直接指导软件的构建，而是生成其他构建系统。再由这些构建系统来编译 C++ 等软件。


CMakeLists -->(CMake) --> Makefle/Ninja --> (autotool/ninja) --> 构建源码。

类似的还有 gn, bluk 等。

为什么不直接构建软件？而要生成构建系统？

为了编译加速，构建系统如果直接由用户编写，很难写的比较优化，而且用户易读的并不一定是构建明确的。例如 C 语言通常会有很多依赖文件，而我们不愿意写构建系统会指定哪个目录的所有文件是源码，哪个目录的所有文件是头文件。而不会为每个源文件明确指定其依赖到的文件。这在构建时，编译器需要查找所有的文件，速度就比较慢。

而元构建系统就是将人编写的模糊构建规则，优化为明确、最佳的编译规则。然后又编译器不需要在逐个查找，加快了编译速度。

这一步为什么编译器/构建系统做不了？

1. 重用：如果构建系统能做，要么分成两步，先优化为规则，然后 build。
    如果是每次构建都动态优化，就不能起到一次构建优化，多次 build 来节省时间。还可能拖累速度。
    如果是优化是重用的，必然要生成文件，其本质还是 元构建系统 + 构建系统。

2. 历史原因：早起的软件比较简单，也没有构建优化的思想。早起的构建软件都比较简单。随着软件的复杂性提高，老的构建系统没有一下退出历史舞台，就出现了元构建系统用于生成构建系统。


现在已经有一下软件想要简化构建流程。例如 Xmake

- 简单工程，不需要任何类似makefile文件，直接检测分析源码，直接编译和运行，用于快速测试临时代码。

- 复杂工程，xmake.lua描述文件构建关系。


CMake支持in-place构建（二进档和源代码在同一个目录树中）和out-of-place构建（二进档在别的目录里），因此可以很容易从同一个源代码目录树中构建出多个二进档。良好的构建应该是独立于源码的，不是所有的软件都有版本控制工具管理，生成代码与源码混在一起弄脏了项目。CMake也支持静态与动态程序库的构建。

构建流程

```
$ cd some_software-1.4.2 // 源码目录
$ mkdir build // 构建目录，cmake 没有提供参数指定生成目录，而是以 cmake 执行的目录作为当前生成目录。
$ cd build // 进入生成目录
$ cmake .. -DCMAKE_INSTALL_PREFIX=/opt/the/prefix // 指定软件安装的目录
$ cmake --build . // 编译。 --build 用于指定编译目录，并且是原构建所在目录。
$ cmake --build . --target install // 安装。
```

## CMake 配置工具

除了在命令行指定参数，CMake 也包含一个交互式的配置工具。

cmake-gui: Windows 上的图形化配置工具。
ccmake: unix lick 系统上 cmake-gui 的等价物，但是是一个命令行的交互式界面。



