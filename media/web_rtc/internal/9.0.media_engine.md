# Media Engine

MediaEngine 用于管理硬件数据流。MediaEngine 的实现 CompositeMediaEngine 是一个聚合类，包含一个 WebRtcVoiceEngine 和 一个 WebRtcVideoEngine（后文称其为 VoiceEngien 和 VideoEngine）。

VoiceEngien/VideoEngine 提供了如下的能力：

- 查询本机支持的编解码。
- 创建 Channel。


WebRtcVoiceEngine 和 WebRtcVideoEngine 用于创建 Channel(数据通道)，

> 协商中的类和传输中的类之间的对应关系

```
     协商                                                `传输`
RtpSenderBase          <------->  ChannelSend / RtpVideoSender
Audio/VideoRtpReceiver <------->  ChannelReceive / RtpVideoStreamReceiver2
                                          ╭-- 一个 ->  voe::ChannelSend {ModuleRtpRtcpImpl2 {RTPSender}, RTPSenderAudio }
                                        ╭-- 一个 ->   webrtc::AudioSendStream
                                      ╭-- 多个 ->  WebRtcAudioSendStream 和 WebRtcAudioReceiveStream
                                 ╭- 一个 -> WebRtcVoiceMediaChannel / WebRtcVideoChannel
RtcTranscervier        <------>  BaseChannel(VoiceChannel/VideoChannel)
```



一个 BaseChannel 包含一个 WebRtcVoiceMediaChannel/WebRtcVideoChannel。

Channel 和 Stream 的创建流程
```
SdpOfferAnswerHandler::CreateChannels 创建 BaseChannel 的子类
↓
RtpTransceiver::CreateChannel/RtpTransceiver::SetChannel()
↓
WebRtcVoiceEngine::CreateMediaChannel/WebRtcVideoEngine::CreateMediaChannel 创建 (WebRtcVoiceMediaChannel 和 WebRtcVideoChannel) 作为参数

创建 Stream
WebRtcVoiceMediaChannel::WebRtcAudioSendStream
↓
DegradedCall::CreateAudioSendStream
↓
Call::CreateAudioSendStream
↓
new AudioSendStream()
```

## Channel


通过 VoiceEngien/VideoEngine 的 `CreateMediaChannel` 来创建一个 `Channel`。

Channel 的实现使用了 Bridge 模式，用于实现上层 Media 和下层网络传输的桥接。

上层的 MediaChannel 是对媒体数据封装，实现是 WebRtcVoiceMediaChannel 和 WebRtcVideoChannel，其两者实现了 Transport 接口，也可以认为是传输层的入口。

下层的 BaseChannel (正在被删除，功能合并到 RtpTransceiver 中)实现了 MediaChannel 的 NetworkInterface 接口，用于发送数据，为了实现 Voice 和 Video 的差异部分。BaseChannel 实现了 VoiceChannel 和 VideoChannel 两个子类。

由于是双向流，BaseChannel 也持有上层 MediaChannel 的引用，用于接收数据的返回。


## Stream

Stream 是 WebRTC 中数据流的抽象，是一个单向流。通过 MediaChannel 的 `AddSendStream` 和 `AddRecvStream` 可以创建一个发送/接收流。也可以通过 `RemoveSendStream` 和 `RemoveRecvStream` 移除流。

Stream 的实现也有好几个类。

AddSendStream/AddRecvStream 创建的 `WebRtcAudioSendStream/WebRtcVideoSendStream` 和 `WebRtcAudioReceiveStream/WebRtcVideoReceiveStream` 其实是对上层的实现的封装。是一种适配器。

- WebRtcAudioSendStream 和 WebRtcAudioReceiveStream 分别是对 webrtc::AudioSendStream 和 webrtc::AudioReceiveStreamImpl。两者都是通过 Call 的 Create<XXX> 来创建的，例如 `Call::AudioSendStream`。

- WebRtcVideoSendStream 和 WebRtcVideoReceiveStream 分别是 VideoSendStream 和 VideoReceiveStream2 的封装。两者也是通过 Call::Create<XXX> 创建的。

可以看到 Stream 上层的实现类名字差别，没有什么规律。通过 Engein 中类的适配，上层能够快速迭代而不影响下层。通过这种方式将修改隔离。之所以上层 Stream 有这么多名字，而不是直接通过修改代码，很大一部分是因为 WebRTC 是开源提供给不同的项目使用的。有时候会需要测试新的实现的性能和影响，同时又不能影响都其它项目。


## 设置编解码器

设计媒体相关的参数，例如编解码器，都是通过 BaseChannel 的对外接口，最终调用 MeidiaChannel 完成的。

媒体协商确定编解码器，而 BaseChannel 是对外的接口，因此在处理 SDP 的 OfferAnswerHanler 中调用 BaseChannel 的 SetSendParameter() 中创建编解码器。


## MediaChannel 的 API


```C++
class MediaChannel {
 public:
  explicit MediaChannel(webrtc::TaskQueueBase* network_thread,
                        bool enable_dscp = false);
  virtual ~MediaChannel();

  virtual cricket::MediaType media_type() const = 0;

  // Sets the abstract interface class for sending RTP/RTCP data.
  virtual void SetInterface(NetworkInterface* iface);
  // Called on the network when an RTP packet is received.
  virtual void OnPacketReceived(rtc::CopyOnWriteBuffer packet,
                                int64_t packet_time_us) = 0;
  // Called on the network thread after a transport has finished sending a
  // packet.
  virtual void OnPacketSent(const rtc::SentPacket& sent_packet) = 0;
  // Called when the socket's ability to send has changed.
  virtual void OnReadyToSend(bool ready) = 0;
  // Called when the network route used for sending packets changed.
  virtual void OnNetworkRouteChanged(
      absl::string_view transport_name,
      const rtc::NetworkRoute& network_route) = 0;
  // Creates a new outgoing media stream with SSRCs and CNAME as described
  // by sp.
  virtual bool AddSendStream(const StreamParams& sp) = 0;
  // Removes an outgoing media stream.
  // SSRC must be the first SSRC of the media stream if the stream uses
  // multiple SSRCs. In the case of an ssrc of 0, the possibly cached
  // StreamParams is removed.
  virtual bool RemoveSendStream(uint32_t ssrc) = 0;
  // Creates a new incoming media stream with SSRCs, CNAME as described
  // by sp. In the case of a sp without SSRCs, the unsignaled sp is cached
  // to be used later for unsignaled streams received.
  virtual bool AddRecvStream(const StreamParams& sp) = 0;
  // Removes an incoming media stream.
  // ssrc must be the first SSRC of the media stream if the stream uses
  // multiple SSRCs.
  virtual bool RemoveRecvStream(uint32_t ssrc) = 0;
  // Resets any cached StreamParams for an unsignaled RecvStream, and removes
  // any existing unsignaled streams.
  virtual void ResetUnsignaledRecvStream() = 0;
  // This is currently a workaround because of the demuxer state being managed
  // across two separate threads. Once the state is consistently managed on
  // the same thread (network), this workaround can be removed.
  // These two notifications inform the media channel when the transport's
  // demuxer criteria is being updated.
  // * OnDemuxerCriteriaUpdatePending() happens on the same thread that the
  //   channel's streams are added and removed (worker thread).
  // * OnDemuxerCriteriaUpdateComplete() happens on the same thread.
  // Because the demuxer is updated asynchronously, there is a window of time
  // where packets are arriving to the channel for streams that have already
  // been removed on the worker thread. It is important NOT to treat these as
  // new unsignalled ssrcs.
  virtual void OnDemuxerCriteriaUpdatePending() = 0;
  virtual void OnDemuxerCriteriaUpdateComplete() = 0;
  // Returns the absoulte sendtime extension id value from media channel.
  virtual int GetRtpSendTimeExtnId() const;
  // Set the frame encryptor to use on all outgoing frames. This is optional.
  // This pointers lifetime is managed by the set of RtpSender it is attached
  // to.
  // TODO(benwright) make pure virtual once internal supports it.
  virtual void SetFrameEncryptor(
      uint32_t ssrc,
      rtc::scoped_refptr<webrtc::FrameEncryptorInterface> frame_encryptor);
  // Set the frame decryptor to use on all incoming frames. This is optional.
  // This pointers lifetimes is managed by the set of RtpReceivers it is
  // attached to.
  // TODO(benwright) make pure virtual once internal supports it.
  virtual void SetFrameDecryptor(
      uint32_t ssrc,
      rtc::scoped_refptr<webrtc::FrameDecryptorInterface> frame_decryptor);

  // Enable network condition based codec switching.
  virtual void SetVideoCodecSwitchingEnabled(bool enabled);

  // Base method to send packet using NetworkInterface.
  bool SendPacket(rtc::CopyOnWriteBuffer* packet,
                  const rtc::PacketOptions& options);

  bool SendRtcp(rtc::CopyOnWriteBuffer* packet,
                const rtc::PacketOptions& options);

  int SetOption(NetworkInterface::SocketType type,
                rtc::Socket::Option opt,
                int option);

  // Corresponds to the SDP attribute extmap-allow-mixed, see RFC8285.
  // Set to true if it's allowed to mix one- and two-byte RTP header extensions
  // in the same stream. The setter and getter must only be called from
  // worker_thread.
  void SetExtmapAllowMixed(bool extmap_allow_mixed);
  bool ExtmapAllowMixed() const;

  // Returns `true` if a non-null NetworkInterface pointer is held.
  // Must be called on the network thread.
  bool HasNetworkInterface() const;

  virtual webrtc::RtpParameters GetRtpSendParameters(uint32_t ssrc) const = 0;
  virtual webrtc::RTCError SetRtpSendParameters(
      uint32_t ssrc,
      const webrtc::RtpParameters& parameters) = 0;

  virtual void SetEncoderToPacketizerFrameTransformer(
      uint32_t ssrc,
      rtc::scoped_refptr<webrtc::FrameTransformerInterface> frame_transformer);
  virtual void SetDepacketizerToDecoderFrameTransformer(
      uint32_t ssrc,
      rtc::scoped_refptr<webrtc::FrameTransformerInterface> frame_transformer);
};
```