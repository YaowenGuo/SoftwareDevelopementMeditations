# Structural Patterns

结构型模式关注于类和对象如何组成大的架构。类结构模式使用继承来实现接口。举一个简单的例子：考虑使用多继承来将两个或更多的类混合成一个类。子类就拥有了所有父类的属性和方法。这种模式对于想要将独立开发的类一起使用特别有效；另一个例子是组成适配器(Adapter)模式的类。通常，适配器使一个接口（ adaptee 的）适应于另一个接口，从而为不同的接口提供统一的抽象。类适配器模式通过自己继承被适配者来实现。然后适配器在自己的接口中调用被适配者的。

对象结构模型不是由继承和实现组成。而是通过对象的组合来实现新的功能。对象组合的灵活性来自于能够在运行时改变组合对象的能力，这是类结构模型所不能实现的。

组合(Composite)是一个对象型结构模式的之一。它描述了如何构建由两种对象的类组成的类层次结构：原始和复合。复合对象允许您将原始对象和其他复合对象组合成任意复杂的结构。对于代理(Proxy)模式，代理充当另一个对象的便捷替代品或占位符。代理可以在许多地方使用。它可以充当远程地址空间中对象的本地代表。它可以代表应按需加载的大对象。它可以用于保护对敏感对象的访问。代理提供了对对象的特定属性的间接级别。 因此，它们可以限制，增强或更改这些属性。

享元(Flyweight)模式定义了共享对象的结构。对象的共享至少有一下两种理由：效率和一致性。Flyweight 专注于共享以提高空间效率。在应用中使用大量的对象谨慎关注于每个对象的消耗。通过共享而不是复制对象，可以节省大量资源。但是对象仅能在没有定义任何上下文依赖状态时才能共享。享元对象没有这些状态。任何在执行任务时需要的额外信息都会在需要时传递给他们。在没有依赖于上下文的状态下，Flyweight 对象可以自由共享。

相对于 Flyweight 展示如何创建许多小对象，而门面(Facade)展示了如何使用单个对象代表整个子系统。门面是一组对象的代表。m门面通过将消息转发给它表示的对象来履行其职责。桥接（Bridge）模式将对象的抽象和实现分离开来，以便你可以独立的更新其中之一。

装饰器(Decorator)描述了如何动态地给对象添加功能。装饰器是一种递归地组成对象的结构模式，以允许不限数量的附加职责。例如，包含用户界面组件的 Decorator 对象可以向该组件添加装饰（如边框或阴影），也可以添加诸如滚动和缩放之类的功能。我们可以通过将一个装饰器对象嵌套到另一个装饰器对象中来添加两个装饰器，以及如此添加更多的功能。为了实现这种能力，每个Decorator对象必须符合其装饰组件的接口，并且必须向组件转发消息。装饰器可以在转发消息之前或之后执行其工作（例如在组件周围绘制边框）。

许多结构模式在某些方面是相关的，在整体认识所有结构模式后想详细讨论它们之间的关联和区别。



